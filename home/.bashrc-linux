# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

export TERM=xterm-256color

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        # We have color support; assume it's compliant with Ecma-48
        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
        # a case would tend to support setf rather than setaf.)
        color_prompt=yes
    else
        color_prompt=
    fi
fi

function parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

if [ "$color_prompt" = yes ]; then
    # PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
	PS1="\w\[\033[01;32m\]\$(parse_git_branch)\[\033[00m\] $ "
else
    # PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
	PS1="\w\$(parse_git_branch) $ "
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r "${HOME}/.dircolors" && eval "$(dircolors -b ${HOME}/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f "${HOME}/.bash_aliases" ]; then
    . "${HOME}/.bash_aliases"
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
[ -r "${HOME}/.byobu/prompt" ] && . "${HOME}/.byobu/prompt"   #byobu-prompt#


export NLTK_DATA="$HOME/dev/py-nlp/var/nltk/data"

export LANG="en_US.UTF-8"
export LANGUAGE="en_US.UTF-8"
export LC_COLLATE="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"
export LC_MESSAGES="en_US.UTF-8"
export LC_MONETARY="en_US.UTF-8"
export LC_NUMERIC="en_US.UTF-8"
export LC_TIME="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

export LESS="-R"
export EDITOR=/usr/local/bin/vim

# Tell grep to highlight matches
# export GREP_OPTIONS='--color=auto'

# Tell ls to be colourful
export CLICOLOR=1
export LSCOLORS=Exfxcxdxbxegedabagacad

# Node: do not use `~' shortcut when referring to home directory
# when exporting paths. Instead, use "$HOME" variable.
#
export NODE_PATH="/usr/local/lib/jsctags:$NODE_PATH"
export NODE_PATH="/usr/local/lib/jsctags:$NODE_PATH"

#pkgconfig
export PKG_CONFIG_PATH="$PKG_CONFIG_PATH:/opt/X11/lib/pkgconfig"

#export PYTHONPATH="$(brew --prefix)/lib/python2.7/site-packages:/usr/local/opt/opencv/lib/python2.7/site-packages:$PYTHONPATH"

alias gipython="ipython qtconsole --pylab=inline"
alias ghci="ghci -XNoMonomorphismRestriction"
alias lwatch="w'tch -n 1 wc -l"
alias parallel="parallel --use-cpus-instead-of-cores --no-notice --bar"

alias gg='git grep'
alias ga='git add'
alias gp='git push'
alias gc='git commit'
alias gd='git diff'
alias g='git'


function findre() { find . -type f -not -wholename '*.git*' -exec egrep -nH "$1" {} \;; }

function gitd() {
    # running gitd -D prefix will remove all branches with that prefix
    git branch | grep -e "^\s*$2" | xargs git branch "$1"
}

function redis_del() {
    # delete Redis keys from database $1 matching pattern $2
    redis-cli -n "$1" --raw keys "$2" | xargs -L1 -I{} redis-cli -n "$1" del {} 1
}

function pdfpextr() {
    # Use Ghostscript to extract a range of pages from a pdf
    # this function uses 3 arguments:
    #     $1 is the first page of the range to extract
    #     $2 is the last page of the range to extract
    #     $3 is the input file
    #     output file will be named "inputfile_pXX-pYY.pdf"
    gs -sDEVICE=pdfwrite -dNOPAUSE -dBATCH -dSAFER \
       -dFirstPage=${1} \
       -dLastPage=${2} \
       -sOutputFile=${3%.pdf}_p${1}-p${2}.pdf \
       ${3}
}

function joinpdf() {
    # Join a number of pdfs into a single file "merged.pdf"
    result=${1}
    shift
    gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=${result} "$@"
}

# http://blog.sinelabs.com/post/57029831523/uwsgi-nginx-mirroring-ubuntu-setup-for-os-x-mountain
function nginxctl {
    if [ $1 == "reload" ]; then
        echo "Unloading Nginx..."
        sudo launchctl unload -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist
        wait
        echo "Loading Nginx..."
        sudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist
    elif [ $1 == "unload" ]; then
        echo "Unloading Nginx..."
        sudo launchctl unload -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist
    elif [ $1 == "load" ]; then
        echo "Loading Nginx..."
        sudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist
    else
        echo "Command $1 unsupported"
    fi
}

export PATH="$HOME/.cabal/bin:$HOME/Library/Haskell/bin:/Library/Haskell/bin:/usr/local/bin:/usr/local/sbin:$PATH"

export GOPATH="/usr/share/go"
export PATH="$PATH:/usr/share/go/bin:/usr/local/go/bin"

export PATH="$PATH:/opt/bin"

export PATH="$HOME/.local/bin:$PATH"

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

export PATH="/usr/local/bin:/usr/local/sbin:/usr/local/heroku/bin:$HOME/Library/Haskell/bin:/Library/Haskell/bin:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/local/share/python:/usr/local/share/npm/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/share/go/bin:/usr/local/go/bin:/opt/bin:/usr/texbin:$PATH"

# test -s "$HOME/.rvm/scripts/rvm" && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
# export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

test -s "${HOME}/.bash_private" && source "${HOME}/.bash_private"

export PYTHONIOENCODING=UTF_8

PERL_MB_OPT="--install_base $HOME/perl5"; export PERL_MB_OPT;
PERL_MM_OPT="INSTALL_BASE=$HOME/perl5"; export PERL_MM_OPT;

export PERL5LIB="$HOME/perl5/lib/perl5"
export PATH="$PATH:$HOME/perl5/bin"

# Load pyenv automatically by adding
# the following to your profile:
# export PATH="$HOME/.pyenv/bin:$PATH"
# eval "$(pyenv init -)"
# eval "$(pyenv virtualenv-init -)"

export LIBFM_PATH="$HOME/.local/bin"

if [ -x /usr/libexec/java_home ]; then
    export JAVA_HOME="`/usr/libexec/java_home -v 1.7`"
fi

export SPARK_HOME="$HOME/dev/spark-1.6.0"
export SPARK_LOCAL_IP=0.0.0.0
export PATH=${SPARK_HOME}/bin${PATH:+:${PATH}}

alias ssh-emr="ssh -i $AWS_KEY $EMR_HOST -t \"tmux new-session -A -s main\""
alias mosh-emr="mosh --ssh=\"ssh -i $AWS_KEY\" $EMR_HOST --server=\"/usr/bin/mosh-server\" -- tmux new-session -A -s main"
alias mosh-emr-bind="mosh --ssh=\"ssh -i $AWS_KEY -ND 8157\" $EMR_HOST --server=\"/usr/bin/mosh-server\""

alias mysql-aurora-dev="mysql -h$AURORA_DEV_HOST -u$DB_USER --port $DB_PORT -p"

alias ssh-spinoza="ssh -Y $SPINOZA -t \"tmux new-session -A -s main\""
alias mosh-spinoza="mosh --ssh=\"ssh -Y\" $SPINOZA --server=\"/usr/bin/mosh-server\" -- tmux new-session -A -s main"
alias vevo-vpn="sudo openconnect --script=~/.local/etc/vpnc-script-split-traffic -u $VPN_USER --authgroup $VPN_GROUP $VPN_HOST"

export PATH=/usr/local/cuda-8.0/bin${PATH:+:${PATH}}
export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}

# added by Anaconda2 4.1.0 installer
export PATH="${HOME}/anaconda2/bin:$PATH"

# http://unix.stackexchange.com/a/48113/172348
export HISTCONTROL=ignoredups:erasedups  # no duplicate entries
export HISTSIZE=100000                   # big big history
export HISTFILESIZE=100000               # big big history
shopt -s histappend                      # append to history, don't overwrite it
# Save and reload the history after each command finishes
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"
